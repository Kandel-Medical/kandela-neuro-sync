<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kandela: Signal-Sync</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: #080808;
            --grid-color: #1a4030;
            --signal-ghost: rgba(0, 255, 157, 0.25);
            --signal-active: #ff3366;
            --signal-locked: #00ff9d;
            --ui-bg: #111;
            --knob-color: #222;
            --knob-indicator: #00ff9d;
            --text-color: #00ff9d;
            --led-off: #331111;
            --led-on: #ff0000;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Share Tech Mono', monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        /* SEGURAN√áA */
        #access-denied {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999;
            flex-direction: column; justify-content: center; align-items: center;
            text-align: center; padding: 20px;
        }
        #access-denied h1 { color: #ff0055; border-bottom: 2px solid #ff0055; }

        /* HEADER */
        #header {
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #000;
            border-bottom: 1px solid var(--grid-color);
            height: 50px;
            z-index: 30;
        }

        .status-badge {
            font-size: 0.8rem;
            padding: 4px 8px;
            border: 1px solid var(--signal-active);
            color: var(--signal-active);
            border-radius: 4px;
            transition: all 0.3s;
            min-width: 100px;
            text-align: center;
        }
        
        .status-badge.locked {
            border-color: var(--signal-locked);
            color: var(--bg-color);
            background: var(--signal-locked);
            box-shadow: 0 0 10px var(--signal-locked);
        }

        /* OSCILOSC√ìPIO */
        #scope-container {
            position: relative;
            flex-grow: 1;
            width: 100%;
            background: radial-gradient(circle, #0c1a12 0%, #000000 90%);
            overflow: hidden;
            cursor: crosshair;
        }

        canvas { width: 100%; height: 100%; display: block; }

        #scope-container::after {
            content: " ";
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* PAINEL DE CONTROLE */
        #control-panel {
            background: var(--ui-bg);
            padding: 15px;
            border-top: 2px solid var(--grid-color);
            display: flex;
            justify-content: space-around;
            align-items: flex-start; 
            height: 190px;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.8);
            z-index: 30;
        }

        .knob-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            width: 30%;
            transition: opacity 0.3s;
        }

        .knob-label {
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            height: 20px;
        }

        .knob-value {
            font-size: 0.85rem;
            color: var(--text-color);
            margin-top: 5px;
        }

        /* KNOB UI */
        .knob-outer {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: conic-gradient(#222 0%, #333 100%);
            box-shadow: inset 0 0 10px #000, 0 5px 15px rgba(0,0,0,0.5);
            position: relative;
            cursor: ew-resize; 
            border: 1px solid #444;
        }

        .knob-outer::before {
            content: '';
            position: absolute;
            top: 10%; left: 10%; right: 10%; bottom: 10%;
            border-radius: 50%;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        .knob-indicator {
            position: absolute;
            top: 50%; left: 50%;
            width: 4px; height: 35%;
            background: var(--knob-indicator);
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(0deg);
            border-radius: 2px;
            box-shadow: 0 0 5px var(--knob-indicator);
            pointer-events: none;
        }

        .knob-disabled { opacity: 0.2; pointer-events: none; filter: grayscale(100%); }

        /* TOGGLE SWITCH (NOTCH) */
        .toggle-container {
            width: 70px; height: 70px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: #1a1a1a; border-radius: 8px;
            border: 1px solid #333;
            box-shadow: inset 0 0 10px #000;
            cursor: pointer;
            position: relative;
        }
        
        .toggle-lever {
            width: 20px; height: 40px;
            background: #444;
            border-radius: 4px;
            position: relative;
            transition: background 0.2s;
        }
        
        .toggle-active .toggle-lever { background: var(--text-color); box-shadow: 0 0 10px var(--text-color); }
        
        .led {
            width: 8px; height: 8px; border-radius: 50%;
            background: var(--led-off);
            margin-bottom: 8px;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
            transition: all 0.2s;
        }
        
        .toggle-active .led { background: var(--text-color); box-shadow: 0 0 5px var(--text-color); }

        /* MODAL */
        #modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            backdrop-filter: blur(5px);
        }
        
        button {
            background: rgba(0, 255, 157, 0.1);
            border: 1px solid var(--text-color);
            color: var(--text-color);
            padding: 15px 40px;
            font-family: inherit;
            font-size: 1.2rem;
            cursor: pointer;
            margin-top: 20px;
            text-transform: uppercase;
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.2);
            transition: all 0.2s;
        }
        
        button:active { background: var(--text-color); color: #000; }

        /* TIP SCREEN (FINAL) */
        .tip-content {
            text-align: left;
            padding: 20px;
            background: rgba(0, 20, 10, 0.9);
            border: 1px solid var(--text-color);
            border-radius: 8px;
            max-width: 85%;
            font-size: 0.9rem;
            line-height: 1.5;
            color: #ddd;
        }
        .tip-path {
            color: var(--signal-locked);
            font-weight: bold;
            margin: 10px 0;
            display: block;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 4px;
        }

        /* RU√çDO */
        .noise-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0.1; pointer-events: none; z-index: 20;
        }
    </style>
</head>
<body>

    <div id="access-denied">
        <h1>üö´ ACESSO NEGADO</h1>
        <p>Acesso permitido apenas via Kandela @ Telegram.</p>
    </div>

    <canvas id="noise-canvas" class="noise-layer"></canvas>

    <div id="header">
        <div>SIGNAL-SYNC <span style="font-size: 0.7em; color: #666;">v5.0 (Neuro-Touch)</span></div>
        <div id="status-badge" class="status-badge">NO SIGNAL</div>
    </div>

    <div id="scope-container">
        <canvas id="scope"></canvas>
    </div>

    <div id="control-panel">
        
        <!-- SLOT 1 -->
        <div class="knob-group" id="group-slot1">
            <div class="knob-label" id="lbl-slot1">GAIN</div>
            <div id="container-knob-1" style="display:block;">
                <div class="knob-outer" id="knob-slot1">
                    <div class="knob-indicator" id="ind-slot1"></div>
                </div>
            </div>
            <div class="knob-value" id="val-slot1">50 uV</div>
        </div>

        <!-- SLOT 2 -->
        <div class="knob-group" id="group-slot2">
            <div class="knob-label" id="lbl-slot2">FREQ</div>
            <div id="container-knob-2" style="display:block;">
                <div class="knob-outer" id="knob-slot2">
                    <div class="knob-indicator" id="ind-slot2"></div>
                </div>
            </div>
            <div class="knob-value" id="val-slot2">10 Hz</div>
        </div>

        <!-- SLOT 3 -->
        <div class="knob-group" id="group-slot3">
            <div class="knob-label" id="lbl-slot3">FASE</div>
            <div id="container-knob-3" style="display:block;">
                <div class="knob-outer" id="knob-slot3">
                    <div class="knob-indicator" id="ind-slot3"></div>
                </div>
            </div>
            <div id="container-switch-3" style="display:none;">
                <div class="toggle-container" id="switch-notch">
                    <div class="led"></div>
                    <div class="toggle-lever"></div>
                </div>
            </div>
            <div class="knob-value" id="val-slot3">0 ms</div>
        </div>

    </div>

    <div id="modal-overlay"></div>

<script>
/**
 * KANDELA: SIGNAL-SYNC v5.0 (Neuro-Touch Edition)
 * - Final Version: Level 9 End Screen with Neurosoft Pro Tip.
 * - Touch Gestures: Pinch (H/V) and Drag for direct signal control.
 * - Physics: Calibrated for EMG/EEG realism (v4.1 physics core).
 */

// --- SEGURAN√áA ---
(function() {
    const tg = window.Telegram.WebApp;
    const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    const isTelegram = tg.initData && tg.initData.length > 0;
    if (!isTelegram && !isLocal) {
        document.getElementById('access-denied').style.display = 'flex';
        throw new Error("Access Denied");
    }
    if(isTelegram) tg.expand();
})();

// --- CONFIGURA√á√ÉO ---
const canvas = document.getElementById('scope');
const ctx = canvas.getContext('2d');
const noiseCanvas = document.getElementById('noise-canvas');
const noiseCtx = noiseCanvas.getContext('2d');
const statusBadge = document.getElementById('status-badge');

// UI Maps
const slots = {
    1: { el: document.getElementById('knob-slot1'), ind: document.getElementById('ind-slot1'), val: document.getElementById('val-slot1'), lbl: document.getElementById('lbl-slot1'), grp: document.getElementById('group-slot1'), contKnob: document.getElementById('container-knob-1') },
    2: { el: document.getElementById('knob-slot2'), ind: document.getElementById('ind-slot2'), val: document.getElementById('val-slot2'), lbl: document.getElementById('lbl-slot2'), grp: document.getElementById('group-slot2'), contKnob: document.getElementById('container-knob-2') },
    3: { el: document.getElementById('knob-slot3'), ind: document.getElementById('ind-slot3'), val: document.getElementById('val-slot3'), lbl: document.getElementById('lbl-slot3'), grp: document.getElementById('group-slot3'), contKnob: document.getElementById('container-knob-3'), contSwitch: document.getElementById('container-switch-3'), switch: document.getElementById('switch-notch') }
};

// Estado
let time = 0;
let isPlaying = false;
let lockTimer = 0;
let currentLevel = 1;
let mode = 'SYNTH'; 
let signalType = 'SINE'; 

// Knobs Defs (Mut√°vel)
let KNOB_DEFS = {
    amp:   { label: 'GAIN', min: 10, max: 200, step: 1, unit: ' uV' },
    freq:  { label: 'FREQ', min: 1, max: 50, step: 0.5, unit: ' Hz' },
    phase: { label: 'FASE', min: 0, max: 100, step: 1, unit: ' ms' },
    hpf:   { label: 'HP FILTER', min: 0.1, max: 50, step: 0.1, unit: ' Hz' }, 
    lpf:   { label: 'LP FILTER', min: 30, max: 10000, step: 10, unit: ' Hz' },
    notch: { label: 'NOTCH 60Hz', type: 'switch' }
};

// Par√¢metros
let params = { amp: 50, freq: 10, phase: 0, hpf: 0.1, lpf: 5000, notch: false };
let target = { amp: 50, freq: 10, phase: 0, harmonics: 0 };
let noiseConfig = { drift: 0, highFreq: 0, hum: 0 }; 
let slotAssignment = { 1: 'amp', 2: 'freq', 3: 'phase' };

// --- GESTURE CONTROLLER (PINCH & DRAG) ---
let gestureState = {
    active: false,
    startDistH: 0,
    startDistV: 0,
    startX: 0,
    startVals: {}
};

canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
canvas.addEventListener('touchend', () => { gestureState.active = false; }, {passive: false});

function handleTouchStart(e) {
    if (!isPlaying) return;
    e.preventDefault();
    gestureState.active = true;
    gestureState.startVals = { ...params }; // Snapshot valores atuais

    if (e.touches.length === 1) {
        // Drag (Fase)
        gestureState.startX = e.touches[0].clientX;
    } 
    else if (e.touches.length === 2) {
        // Pinch
        gestureState.startDistH = Math.abs(e.touches[0].clientX - e.touches[1].clientX);
        gestureState.startDistV = Math.abs(e.touches[0].clientY - e.touches[1].clientY);
    }
}

function handleTouchMove(e) {
    if (!gestureState.active) return;
    e.preventDefault();

    // 1 Dedo: Fase (Arrastar)
    if (e.touches.length === 1) {
        // S√≥ funciona se FASE estiver no slot 3 e habilitado
        if (slotAssignment[3] === 'phase' && !slots[3].grp.classList.contains('knob-disabled')) {
            const currentX = e.touches[0].clientX;
            const delta = currentX - gestureState.startX;
            let newVal = gestureState.startVals.phase + (delta * 0.5); // Sensibilidade
            params.phase = clamp(newVal, KNOB_DEFS.phase.min, KNOB_DEFS.phase.max);
            updateKnobVisual(3, 'phase');
        }
    }
    // 2 Dedos: Pinch
    else if (e.touches.length === 2) {
        const distH = Math.abs(e.touches[0].clientX - e.touches[1].clientX);
        const distV = Math.abs(e.touches[0].clientY - e.touches[1].clientY);

        // Horizontal Pinch -> Freq ou LPF (Slot 2)
        const paramH = slotAssignment[2];
        if (!slots[2].grp.classList.contains('knob-disabled')) {
            const deltaH = distH - gestureState.startDistH;
            const def = KNOB_DEFS[paramH];
            const sensitivity = (def.max - def.min) / 500; 
            let newVal = gestureState.startVals[paramH] + (deltaH * sensitivity);
            // Snap se necess√°rio
            if(def.step) newVal = Math.round(newVal / def.step) * def.step;
            params[paramH] = clamp(newVal, def.min, def.max);
            updateKnobVisual(2, paramH);
        }

        // Vertical Pinch -> Amp ou HPF (Slot 1)
        const paramV = slotAssignment[1];
        if (!slots[1].grp.classList.contains('knob-disabled')) {
            const deltaV = gestureState.startDistV - distV; // Invertido (abrir aumenta)
            const def = KNOB_DEFS[paramV];
            const sensitivity = (def.max - def.min) / 500;
            let newVal = gestureState.startVals[paramV] + (deltaV * sensitivity); // Abrir = diminuir valor visualmente? N√£o, abrir = aumentar
            // Ajuste de dire√ß√£o: Abrir dedos (distV aumenta) -> deltaV negativo. 
            // Queremos aumentar valor ao abrir dedos.
            newVal = gestureState.startVals[paramV] + ((distV - gestureState.startDistV) * sensitivity);
            
            if(def.step) newVal = Math.round(newVal / def.step) * def.step;
            params[paramV] = clamp(newVal, def.min, def.max);
            updateKnobVisual(1, paramV);
        }
    }
}

function clamp(val, min, max) {
    return Math.max(min, Math.min(max, val));
}

// --- RU√çDO ---
function initNoise() {
    noiseCanvas.width = 256; noiseCanvas.height = 256;
    const w = noiseCanvas.width; const h = noiseCanvas.height;
    const idata = noiseCtx.createImageData(w, h);
    const buffer32 = new Uint32Array(idata.data.buffer);
    for (let i = 0; i < buffer32.length; i++) buffer32[i] = (Math.random() < 0.5) ? 0xffffffff : 0x00000000;
    noiseCtx.putImageData(idata, 0, 0);
}
function animateNoise() {
    const rx = Math.floor(Math.random() * 50);
    const ry = Math.floor(Math.random() * 50);
    noiseCanvas.style.transform = `translate(-${rx}px, -${ry}px)`;
    requestAnimationFrame(animateNoise);
}

// --- ENGINE DE N√çVEIS ---

function showBriefing(lvl) {
    const modal = document.getElementById('modal-overlay');
    modal.style.display = 'flex';
    let title = (lvl >= 4) ? "FILTRAGEM" : "CALIBRA√á√ÉO";
    let instr = (lvl >= 4) ? "Use os filtros para LIMPAR o ru√≠do." : "Sincronize a onda VERMELHA.";
    
    if (lvl === 7) { title = "MASTER CLASS"; instr = "Condi√ß√µes cr√≠ticas: Sinal sujo + Harm√¥nicas."; }
    if (lvl === 8) { 
        title = "ELETROMIOGRAFIA"; 
        instr = "Sinal EMG (R√°pido).<br>Alvo: <strong>HPF 20Hz</strong> | <strong>LPF 5kHz</strong>.<br>Evite LPF > 7kHz para n√£o 'engrossar' o tra√ßado."; 
    }
    if (lvl === 9) { 
        title = "ELETROENCEFALO"; 
        instr = "Sinal EEG (Lento).<br>Alvo: <strong>HPF 1-5 Hz</strong> | <strong>LPF 75-100 Hz</strong>.<br>Ligue o NOTCH para remover 60Hz."; 
    }
    
    modal.innerHTML = `
        <h1 style="margin:0; font-size: 2rem; color: var(--text-color); text-shadow: 0 0 10px var(--text-color);">${title}</h1>
        <p style="max-width: 80%; margin: 20px 0; color: #aaa;">${instr}</p>
        <div id="level-info" style="color: #fff; margin-bottom: 20px; font-weight: bold; border: 1px solid #333; padding: 10px;">${getLevelName(lvl)}</div>
        <button id="btn-start">INICIAR</button>
        <div style="margin-top: 20px; font-size: 0.7rem; color: #444;">v5.0 (Neuro-Touch)</div>
    `;
    document.getElementById('btn-start').onclick = () => startLevel(lvl);
}

// TELA FINAL DE DICA (Neurosoft Pro Tip)
function showVictoryScreen() {
    const modal = document.getElementById('modal-overlay');
    modal.style.display = 'flex';
    modal.innerHTML = `
        <h1 style="color:#00ff9d; font-size: 2.5rem; margin-bottom:10px;">EXCELENTE!</h1>
        <div class="tip-content">
            <strong>DICA ESPECIALISTA:</strong><br><br>
            Caso tenha d√∫vidas de qual filtro √© o melhor para determinada t√©cnica, consulte os ajustes padr√£o no software Neurosoft:
            <span class="tip-path">
                Configurar ‚Üí Modelos de Teste ‚Üí Personalizar ‚Üí [Teste] ‚Üí Hardware ‚Üí Litebox
            </span>
            L√° voc√™ pode consultar os filtros, margem de entrada e taxa de amostragem ideais.
        </div>
        <button id="btn-restart">REINICIAR SISTEMA</button>
    `;
    document.getElementById('btn-restart').onclick = () => showBriefing(1);
}

function getLevelName(lvl) {
    if(lvl === 1) return "N√çVEL 1: Ganho & Fase";
    if(lvl === 2) return "N√çVEL 2: Frequ√™ncia & Fase";
    if(lvl === 3) return "N√çVEL 3: Calibra√ß√£o Completa";
    if(lvl === 4) return "N√çVEL 4: High & Low Pass";
    if(lvl === 5) return "N√çVEL 5: Notch (Rede El√©trica)";
    if(lvl === 6) return "N√çVEL 6: Filtros Combinados";
    if(lvl === 7) return "N√çVEL 7: Master Class";
    if(lvl === 8) return "N√çVEL 8: EMG (Banda Larga)";
    if(lvl === 9) return "N√çVEL 9: EEG (Banda Estreita)";
    return "N√çVEL " + lvl;
}

function resetUIState() {
    for (let i = 1; i <= 3; i++) {
        slots[i].grp.classList.remove('knob-disabled');
    }
}

function startLevel(lvl) {
    currentLevel = lvl;
    resetUIState(); 

    params = { amp: 50, freq: 10, phase: 0, hpf: 0.1, lpf: 5000, notch: false };
    noiseConfig = { drift: 0, highFreq: 0, hum: 0 };
    signalType = 'SINE'; 
    
    // Reset Knob Ranges
    KNOB_DEFS.hpf.min = 0.1; KNOB_DEFS.hpf.max = 50; KNOB_DEFS.hpf.step = 0.1;
    KNOB_DEFS.lpf.min = 30; KNOB_DEFS.lpf.max = 10000; KNOB_DEFS.lpf.step = 10;

    if (lvl <= 3) {
        mode = 'SYNTH';
        setupSynthLevel(lvl);
    } else {
        mode = 'FILTER';
        setupFilterLevel(lvl);
    }

    updateUI(); 
    isPlaying = true;
    lockTimer = 0;
    document.getElementById('modal-overlay').style.display = 'none';
    if (!window.animationFrameId) loop();
}

function setupSynthLevel(lvl) {
    slotAssignment = { 1: 'amp', 2: 'freq', 3: 'phase' };
    target.freq = 5; target.amp = 100; target.phase = 50; target.harmonics = 0;

    if (lvl === 1) {
        target.amp = randomRange(60, 140); target.phase = randomRange(20, 80); target.freq = 5; 
        params.freq = target.freq; disableSlot(2); 
    } 
    else if (lvl === 2) {
        target.amp = 100; target.freq = randomRange(5, 15); target.phase = randomRange(20, 80);
        params.amp = target.amp; disableSlot(1); 
    } 
    else {
        target.freq = randomRange(3, 15); target.amp = randomRange(50, 150); target.phase = randomRange(10, 90);
    }
}

function setupFilterLevel(lvl) {
    slotAssignment = { 1: 'hpf', 2: 'lpf', 3: 'notch' };
    target = { freq: 10, amp: 80, phase: 0, harmonics: 0.5 };
    
    if (lvl === 4) {
        noiseConfig.drift = 60; noiseConfig.highFreq = 30;
        disableSlot(3); 
        params.hpf = 0.1; params.lpf = 5000;
    }
    else if (lvl === 5) {
        noiseConfig.hum = 50; noiseConfig.drift = 20;
        params.notch = false;
        disableSlot(2); 
    }
    else if (lvl === 6) {
        noiseConfig.drift = 50; noiseConfig.highFreq = 40; noiseConfig.hum = 60;
    }
    else if (lvl === 7) {
        target.harmonics = 0.8; noiseConfig.drift = 80; noiseConfig.highFreq = 60; noiseConfig.hum = 80;
    }
    else if (lvl === 8) {
        signalType = 'EMG'; target.amp = 70;
        noiseConfig.drift = 30; noiseConfig.highFreq = 5; 
        disableSlot(3); 
        params.hpf = 0.1; params.lpf = 100; 
    }
    else if (lvl === 9) {
        signalType = 'EEG';
        target.amp = 100;
        noiseConfig.drift = 120; 
        noiseConfig.hum = 80; 
        noiseConfig.highFreq = 25; 
        
        KNOB_DEFS.lpf.min = 35; KNOB_DEFS.lpf.max = 500; KNOB_DEFS.lpf.step = 5;
        KNOB_DEFS.hpf.min = 0.1; KNOB_DEFS.hpf.max = 15.0; KNOB_DEFS.hpf.step = 0.1;
        
        params.hpf = 0.1; params.lpf = 500; params.notch = false; 
    }
    
    params.amp = target.amp; 
}

function disableSlot(n) {
    slots[n].grp.classList.add('knob-disabled');
}

function updateUI() {
    for (let i = 1; i <= 3; i++) {
        const paramName = slotAssignment[i];
        const def = KNOB_DEFS[paramName];

        if (def.type === 'switch') {
            slots[i].contKnob.style.display = 'none';
            if(slots[i].contSwitch) slots[i].contSwitch.style.display = 'flex';
            slots[i].lbl.innerText = def.label;
            slots[i].val.innerText = params[paramName] ? "ON" : "OFF";
            updateSwitchVisual(i, params[paramName]);
        } else {
            slots[i].contKnob.style.display = 'block';
            if(slots[i].contSwitch) slots[i].contSwitch.style.display = 'none';
            slots[i].lbl.innerText = def.label;
            updateKnobVisual(i, paramName);
        }
    }
}

function updateSwitchVisual(slotIdx, isOn) {
    const el = slots[slotIdx].switch;
    if (isOn) el.classList.add('toggle-active'); else el.classList.remove('toggle-active');
}

function updateKnobVisual(slotIdx, paramName) {
    const def = KNOB_DEFS[paramName];
    const val = params[paramName];
    let percent = (val - def.min) / (def.max - def.min);
    const deg = -135 + (percent * 270);
    slots[slotIdx].ind.style.transform = `translate(-50%, -100%) rotate(${deg}deg)`;
    
    let txt = val;
    if (paramName === 'lpf') txt = (val >= 1000) ? (val/1000).toFixed(1) + 'k' : Math.round(val);
    else if (paramName === 'hpf') txt = val.toFixed(1);
    else txt = Math.round(val);
    slots[slotIdx].val.innerText = txt + def.unit;
}

// --- INPUTS (KNOBS SWIPE) ---
[1, 2, 3].forEach(i => {
    const el = slots[i].el;
    let startX = 0; let startVal = 0;
    
    const move = (e) => {
        const paramName = slotAssignment[i];
        if (KNOB_DEFS[paramName].type === 'switch' || slots[i].grp.classList.contains('knob-disabled')) return;
        
        const x = e.touches ? e.touches[0].clientX : e.clientX;
        const def = KNOB_DEFS[paramName];
        const sensitivity = (def.max - def.min) / 200; 
        
        let newVal = startVal + ((x - startX) * sensitivity);
        newVal = Math.max(def.min, Math.min(def.max, newVal));
        if(def.step) newVal = Math.round(newVal / def.step) * def.step;

        params[paramName] = newVal;
        updateKnobVisual(i, paramName);
    };

    const start = (x) => {
        const paramName = slotAssignment[i];
        if (KNOB_DEFS[paramName].type === 'switch') return;
        startX = x; startVal = params[paramName];
        window.addEventListener('mousemove', move);
        window.addEventListener('touchmove', move, {passive:false});
        window.addEventListener('mouseup', end);
        window.addEventListener('touchend', end);
    };

    const end = () => {
        window.removeEventListener('mousemove', move); window.removeEventListener('touchmove', move);
        window.removeEventListener('mouseup', end); window.removeEventListener('touchend', end);
        if(window.Telegram.WebApp.HapticFeedback) window.Telegram.WebApp.HapticFeedback.selectionChanged();
    };

    el.addEventListener('mousedown', e => start(e.clientX));
    el.addEventListener('touchstart', e => start(e.touches[0].clientX), {passive:false});
});

if(slots[3].switch) slots[3].switch.addEventListener('click', () => {
    const paramName = slotAssignment[3];
    if (KNOB_DEFS[paramName].type === 'switch' && !slots[3].grp.classList.contains('knob-disabled')) {
        params[paramName] = !params[paramName];
        slots[3].val.innerText = params[paramName] ? "ON" : "OFF";
        updateSwitchVisual(3, params[paramName]);
        if(window.Telegram.WebApp.HapticFeedback) window.Telegram.WebApp.HapticFeedback.selectionChanged();
    }
});

// --- LOOP & PHYSICS v4.1 ---
function loop() {
    if (!isPlaying) { window.animationFrameId = null; return; }
    window.animationFrameId = requestAnimationFrame(loop);
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const w = canvas.width; const h = canvas.height; const cy = h/2;
    drawGrid(w, h);

    let totalDiff = 0;
    let samples = 150; 

    for(let i=0; i<samples; i++) {
        let x = (i/samples) * w; let t = x * 0.01;
        let yTarget = generateSignal(t, target, signalType);
        let yPlayer = (mode === 'SYNTH') ? generateSignal(t, params, signalType) : applyPhysics(t, target, noiseConfig, params, signalType);
        totalDiff += Math.abs(yTarget - yPlayer);
    }

    let avgDiff = totalDiff / samples;
    let signalAmp = target.amp || 50;
    let errorRatio = avgDiff / signalAmp; 
    
    let penaltyFactor = (signalType === 'EMG' || signalType === 'EEG') ? 3.0 : 5.0;
    let accuracy = Math.max(0, 100 - (errorRatio * 100 * penaltyFactor)); 

    if (accuracy > 95) { 
        lockTimer++;
        if (lockTimer % 30 === 0 && window.Telegram.WebApp.HapticFeedback) window.Telegram.WebApp.HapticFeedback.selectionChanged();
    } else {
        lockTimer = Math.max(0, lockTimer - 3); 
    }

    let lockPercent = Math.min(100, (lockTimer / 100) * 100); 
    let noiseOpacity = Math.max(0.02, 0.3 - (accuracy / 200)); 
    noiseCanvas.style.opacity = noiseOpacity;

    if (accuracy > 95) {
        statusBadge.innerText = `LOCKING... ${Math.floor(lockPercent)}%`;
        statusBadge.classList.add('locked');
    } else {
        statusBadge.innerText = `SINAL ${Math.floor(accuracy)}%`;
        statusBadge.classList.remove('locked');
    }

    if (lockTimer > 100) winLevel();

    time += 0.05;
    
    drawWave(ctx, w, cy, (t) => generateSignal(t, target, signalType), 'rgba(0, 255, 157, 0.2)', 4);
    let playerColor = accuracy > 95 ? '#00ff9d' : '#ff3366';
    let func = (mode === 'SYNTH') ? (t) => generateSignal(t, params, signalType) : (t) => applyPhysics(t, target, noiseConfig, params, signalType);
    drawWave(ctx, w, cy, func, playerColor, 3);
}

function generateSignal(t, p, type) {
    let rad = (p.phase / 100) * (Math.PI * 2);
    if (type === 'EMG') {
        let carrier = Math.sin((p.freq * 0.5) * t + rad); 
        let noise = Math.sin(t * 30) * Math.cos(t * 13 + rad); 
        return p.amp * carrier * noise;
    } 
    else if (type === 'EEG') {
        let delta = Math.sin((p.freq * 0.2) * t + rad);
        let theta = 0.5 * Math.sin((p.freq * 0.5) * t + rad + 1);
        return p.amp * (delta + theta);
    }
    else {
        let y = p.amp * Math.sin((p.freq * 0.5) * t + rad);
        if (p.harmonics > 0) y += (p.amp * 0.5) * Math.sin((p.freq * 1.0) * t + rad);
        return y;
    }
}

function applyPhysics(t, signalP, noiseC, filterP, type) {
    let y = generateSignal(t, signalP, type);
    
    if (type === 'EMG') {
        let lpfPenalty = Math.max(0, 1 - (filterP.lpf / 4000)); y *= (1 - lpfPenalty);
        let hpfPenalty = Math.max(0, (filterP.hpf - 100) / 100); y *= Math.max(0, 1 - hpfPenalty);
    }
    if (type === 'EEG') {
        let hpfPenalty = Math.max(0, (filterP.hpf - 5) / 5); 
        y *= (1 - hpfPenalty);
    }

    let driftAmp = noiseC.drift * Math.sin(t * 0.3 + time);
    let hpfClean = Math.min(1, filterP.hpf / 1.5); 
    y += driftAmp * (1 - hpfClean);

    let noiseVal = noiseC.highFreq * Math.sin(t * 50 + Math.random());
    
    if (type === 'EMG' && filterP.lpf > 7000) {
        let extraNoise = (filterP.lpf - 7000) / 3000; 
        noiseVal += 20 * extraNoise * Math.cos(t * 80);
    }

    let lpfClean = 0;
    if (type === 'EEG') {
        if (filterP.lpf < 75) {
            lpfClean = 1.0; 
        } else if (filterP.lpf <= 200) {
            lpfClean = Math.max(0, 1 - ((filterP.lpf - 75) / 200)); 
        } else {
            lpfClean = 0;
        }
    } else {
        lpfClean = Math.max(0, 1 - (filterP.lpf / 12000)); 
    }
    y += noiseVal * (1 - lpfClean);

    if (!filterP.notch && noiseC.hum > 0) {
        y += noiseC.hum * Math.sin(t * 20 + time*10);
    }

    return y;
}

function drawWave(ctx, w, cy, func, color, lw) {
    ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = lw;
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.shadowBlur = 10; ctx.shadowColor = color;
    for (let x = 0; x < w; x+=4) {
        let val = func(x * 0.01);
        if(x===0) ctx.moveTo(x, cy - val); else ctx.lineTo(x, cy - val);
    }
    ctx.stroke(); ctx.shadowBlur = 0;
}

function drawGrid(w, h) {
    ctx.beginPath(); ctx.strokeStyle = '#1a4030'; ctx.lineWidth = 1;
    for(let x=0; x<w; x+=50) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
    for(let y=0; y<h; y+=50) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
    ctx.stroke();
    ctx.beginPath(); ctx.strokeStyle = '#2a6045'; ctx.lineWidth = 2;
    ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
}

function winLevel() {
    isPlaying = false;
    statusBadge.innerText = "SINAL CAPTURADO";
    if(window.Telegram.WebApp.HapticFeedback) window.Telegram.WebApp.HapticFeedback.notificationOccurred('success');
    
    if (currentLevel === 9) {
        setTimeout(showVictoryScreen, 500);
    } else {
        setTimeout(() => {
            const modal = document.getElementById('modal-overlay');
            modal.style.display = 'flex';
            modal.innerHTML = `
                <h1 style="color:#00ff9d; font-size: 3rem; margin:0;">SUCESSO</h1>
                <p style="color:#fff; margin-bottom:30px;">Sinal calibrado.</p>
                <button id="btn-next-level">PR√ìXIMO N√çVEL</button>
            `;
            document.getElementById('btn-next-level').onclick = () => showBriefing(currentLevel + 1);
        }, 500);
    }
}

function resize() {
    canvas.width = document.getElementById('scope-container').clientWidth;
    canvas.height = document.getElementById('scope-container').clientHeight;
    noiseCanvas.width = window.innerWidth + 100; noiseCanvas.height = window.innerHeight + 100;
    initNoise();
}
window.addEventListener('resize', resize);
function randomRange(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

resize(); initNoise(); animateNoise(); showBriefing(1);

</script>
</body>
</html>
